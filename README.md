# State Hook

State Hook是一个在函数组件中使用的函数 useState,用于在函数组件中使用状态

## useState

1. useState 函数有一个参数,值表示状态的默认值
2. 函数的返回值是个数组,一定包含两项
   - 第一项:当前状态的值
   - 第二项:改变状态的函数

## State Hook 原理

当运行一个函数组件,
   1. 第N次调用useState
   2. 首先查看**状态数组里**存不存下标n
   3. 如果不存在
      - 使用默认值创建一个状态
      - 该状态加入到状态数组中 下标为n
   4. 如果存在
      - 忽略掉默认值
      - 直接得到状态值

**State细节**

1. useState最好写到函数的起始位置,便于阅读
2. useState严禁出现在代码块(判断、循环)中
3. useState返回的函数(数组的第二项),引用不变(节约内存空间)
4. 如果使用函数改变数据,若数据和之前的数据完全相等(使用Object.is比较),不会导致重新渲染
5. 使用函数改变数据的时候,传入的值不会和原来的数据进行合并,而是直接替换
6. 如果要实现强制刷新组件
   - 类组件:使用forceUpdate函数
   - 函数组件:使用空对象的useState
7. 如果某些状态之间没有必然的联系,应该分化为不同的状态
8. 和类组件的状态一样,函数组件中改变状态可能是异步的(在DOM事件中),
   多个状态变化会合并以提高效率,此时,不能信任    之前的状态,而应该使用毁掉函数的方式改变状态

# Effect Hook

EffectHook:用于在函数组件处理副作用

副作用:
1. ajax请求
2. 计时器
3. 其他异步操作
4. 更改真实dom对象
5. 本地储存
6. 其他会对外部产生影响的操作

函数:useEffect,该函数接收一个函数作为参数,接收的函数就是需要进行副作用操作的函数

**Effect细节**

1. 副作用函数的运行时间点,是在页面完成真实的UI渲染之后.因此它的执行时异步的,不会阻塞浏览器
   1. 与类组件componentDidMount和componentDidUpdate的区别
   2. componentDidMount和componentDidUpdate,更改了真实DOM,但是用户还没有看到UI更新,同步的
   3. useEffect中的副作用函数,更改了真实DOM,丙炔用户已经看到了UI更新,异步的
2. 每个函数组件中,可以多次使用useEffect,但是不要放入判断或循环等代码块中
3. useEffect 中的副作用函数，可以有返回值，返回值必须是一个函数,该函数叫做*清理函数*
   1. 该函数运行时间点在每次运行副作用函数之前
   2. 首次加载不会运行
   3. ``组件``被销毁时,一定会运行
4. useEffect可以传递第二个参数
   1. 第二个参数是个数组
   2. 数组中记录该副作用的依赖数据
   3. 当重新渲染后,只有依赖数据与上一次不一样时,才会执行副作用
   4. 所以,当传递了依赖数据以后,如果数据没有发生变化
      1. 副作用函数仅在第一次渲染后运行
      2. 清理函数仅在卸载组件后运行
5. 副作用函数中,如果使用了函数上下文中的变量,则由于闭包的影响,会导致副作用函数中变量不会实时变化
6. 副作用函数在每次注册时,会覆盖掉之前的副作用函数,因此,尽量保持副作用函数稳定,否则控制起来会比较复杂



# 自定义Hook

自定义Hook:将一些常用的、跨越多个组件的Hook功能,抽离出去形成一个函数,该函数就是自定义Hook;由于其内部需要使用Hook功能没所以它本身也需要按照Hook的规则实现:

   1. 函数名必须以use开头
   2. 调用自定义Hook函数时,应该放到顶层

例如:
1. 很多组件都需要在第一次加载完成后获取所有学生的数据
2. 很多组件都需要在第一次加载完成后启动一个计时器然后在组件销毁是清除计时器

> 使用Hook的时候如果没有严格按照Hook的规则进行,
> eslint的一个插件(eslint-plugin-react-hooks)会报出一个警告


# Reducer Hook

Flux:Facebook出的一个数据流框架

1. 规定了数据是单向流动的
2. 数据存储在数据仓库中(目前可以认为state就是一个存储数据的仓库)
3. action是改变数据的唯一原因(本质上就是一个对象,action有2个属性)
   1. type:字符串,动作的类型
   2. payload:任意类型,动作发生后的附加信息
   3. 例如,如果是添加一个学生:action可以描述为:
      > ```{type:"addStudents",payload:{学生对象的各种信息}}```
   4. 例如,如果是要删除一个学生,action可以描述为:
      > ```{type:"deleteStudents",payload:学生id}```

4. 具体改变数据的是一个函数,叫reducer
   1. 该函数接收两个参数
      1. state:表示当前数据仓库中的数据
      2. action:描述了如何去改变数据,以及改变数据的一些附加信息
   2. 该函数必须有一个返回结果,用于表示数据仓库变化之后的数据
      1. Flux要求,对象是不可变的,如果返回对象,必须创建新的对象
   3. reducer必须是纯函数,不能有任何副作用
5. 如果要触发reducer,不可以直接调用,而是应该调用一个辅助函数dispatch
   1. 该函数仅接收一个参数:action
   2. 该函数会间接调用reducer,以达到改变数据的目的

# Context Hook

用于上下文的数据